// Licence: Lesser GNU Public License 2.1 (LGPL)#pragma rtGlobals=3j		// Use modern global access method.// file generated by EC-Lab (Bio-Logic-Science Instruments)// http://www.bio-logic.info/potentiostat-electrochemistry-ec-lab/// based on https://github.com/chatcannon/galvani (cfffeee2e2 , 2014-05-02)Menu "Macros"	submenu "Import Tool "+importloaderversion		submenu "E-Chem"			"EC-Lab raw						*.mpr	file... beta", BIOLOGICmpr_load_data()			//"EC-Lab procressed				*.mpp	file... beta", //BIOLOGICmpp_load_data()		end	endendstructure mprmoduleheader	//char shortname[10]	//char longname[25] // somehow it reads the wrong amount of chars	//uint32 length		//uint32 version	//uchar mydate[8]	string shortname	string longname	variable length	variable version	string mydate	string header // my header (not of the file)endstructurestructure type	variable type	string name	string wave_name	variable readflags	variable readflags2	variable read	variable maskendstructurestructure alltypes	variable ID[100]	struct type type[100]endstructurestatic function BIOLOGICmpr_read_moduleobject(file, mprhdr)	variable file ; struct mprmoduleheader &mprhdr		string tmps = ""	variable oldpos	do		Fstatus file ; oldpos=V_filePOS		tmps = mybinread(file, 6)		if(cmpstr(tmps,"MODULE")!=0)			Debugprintf2("Expected start of MODULE list!",0)			fsetpos file, oldpos			return -1		else			break		endif		Fstatus file	while(V_logEOF>V_filePOS)	BIOLOGICmpr_readmodulehdr(file, mprhdr)	return 0endstatic function BIOLOGICmpr_readmodulehdr(file, mprhdr)	variable file ; struct mprmoduleheader &mprhdr	//fbinread /B=0 file, mprhdr	//print mprhdr	mprhdr.shortname = mybinread(file, 10)	mprhdr.longname = mybinread(file, 25)	Fbinread/B=3/U/f=3 file, mprhdr.length	Fbinread/B=3/U/f=3 file, mprhdr.version	mprhdr.mydate =  mybinread(file, 8)		return 0endstatic function BIOLOGICmpr_check_datatype(ID, type)	variable ID; struct type &type	switch(ID)		case 1:			type.type=1			type.name="mode"			type.wave_name = "mode"			type.mask = 3 // 0x03			if(type.readflags==1)				type.read = 0			else				type.read = 1				type.readflags = 1			endif			break		case 2:			type.type=1			type.name="ox/red"			type.wave_name = "oxred"			type.mask = 4 // 0x04			if(type.readflags==1)				type.read = 0			else				type.read = 1				type.readflags = 1			endif			break		case 3:			type.type=1			type.name="error"			type.wave_name = "error"			type.mask = 8 // 0x08			if(type.readflags==1)				type.read = 0			else				type.read = 1				type.readflags = 1			endif			break		case 4:			type.type=5			type.name="time/s"			type.wave_name = "time"			type.read = 1			break		case 5:			type.type=4			type.name="control/V/mA"			type.wave_name = "controlP"			type.read = 1			break		case 6:			type.type=4			type.name="Ewe/V"			type.wave_name = "Ewe"			type.read = 1			break		case 7:			type.type=5			type.name="dQ/mA.h"			type.wave_name = "dQ"			type.read = 1			break		case 8:			type.type=4			type.name="I/mA"			type.wave_name = "current"			type.read = 1			break		case 9:			type.type=4 			type.name="Ece/V"			type.wave_name = "Ece"			type.read = 1			break		case 11:			type.type=5			type.name="I/mA"			type.wave_name = "current"			type.read = 1			break		case 13:			type.type=5			type.name="(Q-Qo)/mA.h"			type.wave_name = "Q-Qo"			type.read = 1			break		case 16:			type.type=4 			type.name="Analog IN 1/V"			type.wave_name = "Analog IN 1"			type.read = 1			break		case 17:			type.type=4 			type.name="Analog IN 2/V"			type.wave_name = "Analog IN 2"			type.read = 1			break		case 19:			type.type=4			type.name="control/V"			type.wave_name = "controlV"			type.read = 1			break		case 20:			type.type=4 			type.name="control/mA"			type.wave_name = "controlmA"			type.read = 1			break		case 21:			type.type=1			type.name="control changes"			type.wave_name = "controlchanges"			type.mask = 16 // 0x10			if(type.readflags==1)				type.read = 0			else				type.read = 1				type.readflags = 1			endif			break		case 23:			type.type=5			type.name="dQ/mA.h"			type.wave_name = "dq"			type.read = 1			break		case 24:			type.type=5			type.name="cyclic number"			type.wave_name = "cyclenumber"			type.read = 1			break		case 31:			type.type=1			type.name="Ns changes"			type.wave_name = "Ns"			type.mask = 32 // 0x20			if(type.readflags==1)				type.read = 0			else				type.read = 1				type.readflags = 1			endif			break		case 32:			type.type=4			type.name="freq/Hz "			type.wave_name = "freq"			type.read = 1			break		case 33:			type.type=4			type.name="|Ewe|/V"			type.wave_name = "|Ewe|"			type.read = 1			break		case 34:			type.type=4			type.name="|I|/A"			type.wave_name = "|I|"			type.read = 1			break		case 35:			type.type=4			type.name="Phase(Z)/deg"			type.wave_name = "Phase(Z)"			type.read = 1			break		case 36:			type.type=4			type.name="|Z|/Ohm"			type.wave_name = "|Z|"			type.read = 1			break		case 37:			type.type=4			type.name="Re(Z)/Ohm"			type.wave_name = "Re(Z)"			type.read = 1			break		case 38:			type.type=4			type.name="-Im(Z)/Ohm"			type.wave_name = "-Im(Z)"			type.read = 1			break		case 39:			type.type=2			type.name="I Range"			type.wave_name = "I Range"			type.read = 1			break		case 50:			type.type=4			type.name="E0/V"			type.wave_name = "E0"			type.read = 1			break		case 65:			type.type=1			type.name="counter inc."			type.wave_name = "counter"			type.mask = 128 // 0x80			if(type.readflags==1)				type.read = 0			else				type.read = 1				type.readflags = 1			endif			break		case 70:			type.type=4			type.name="P/W"			type.wave_name = "power"			type.read = 1			break		case 73:			type.type=4			type.name="control/rpm"			type.wave_name = "control"			type.read = 1			break				case 74:			type.type=5			type.name="Energy/W.h"			type.wave_name = "Energy"			type.read = 1			break		case 75:			type.type=4			type.name="Analog OUT/V"			type.wave_name = "Analog OUT"			type.read = 1			break		case 76:			type.type=4			type.name="<I>/mA"			type.wave_name = "<I>"			type.read = 1			break		case 77:			type.type=4			type.name="<Ewe>/V"			type.wave_name = "<Ewe>"			type.read = 1			break		case 78:			type.type=4			type.name="Cs-2/µF-2"			type.wave_name = "Cs-2"			type.read = 1			break		case 86:			type.type=4			type.name="Unk1"			type.wave_name = "Unk1"			type.read = 1			break		case 96:			type.type=4			type.name="|Ece|/V"			type.wave_name = "|Ece|"			type.read = 1			break		case 97:			type.type=4			type.name="|Ice|/A"			type.wave_name = "|Ice|"			type.read = 1			break		case 98:			type.type=4 			type.name="Phase(Zce)/deg"			type.wave_name = "Phase(Zce)"			type.read = 1			break		case 99:			type.type=4 			type.name="|Zce|/Ohm"			type.wave_name = "|Zce|"			type.read = 1			break		case 100:			type.type=4 			type.name="Re(Zce)/Ohm"			type.wave_name = "Re(Zce)"			type.read = 1			break		case 101:			type.type=4			type.name="-Im(Zce)/Ohm"			type.wave_name = "-Im(Zce)"			type.read = 1			break		case 131:			type.type=2			type.name="??"			type.wave_name = "??"			type.mask = 1 // 0x0001			if(type.readflags2==1)				type.read = 0			else				type.read = 1				type.readflags2 = 1			endif			break		case 163:			type.type=4			type.name="|Estack|/V"			type.wave_name = "|Estack|"			type.read = 1			break		case 169:			type.type=4			type.name="Cs/µF"			type.wave_name = "Cs"			type.read = 1			break		case 172:			type.type=4			type.name="Cp/µF"			type.wave_name = "Cp"			type.read = 1			break		case 173:			type.type=4			type.name="Cp-2/µF-2"			type.wave_name = "Cp-2"			type.read = 1			break		case 209:			type.type=5			type.name="pad number"			type.wave_name = "pad number"			type.read = 1			break		case 241:			type.type=4			type.name="|E1|/V"			type.wave_name = "|E1|"			type.read = 1			break		case 242:			type.type=4			type.name="|E2|/V"			type.wave_name = "|E2|"			type.read = 1			break		case 243:			type.type=4			type.name="|E3|/V"			type.wave_name = "|E3|"			type.read = 1			break		case 244:			type.type=4			type.name="|E4|/V"			type.wave_name = "|E4|"			type.read = 1			break		case 245:			type.type=4			type.name="|E5|/V"			type.wave_name = "|E5|"			type.read = 1			break		case 246:			type.type=4			type.name="|E6|/V"			type.wave_name = "|E6|"			type.read = 1			break		case 247:			type.type=4			type.name="|E7|/V"			type.wave_name = "|E7|"			type.read = 1			break		case 248:			type.type=4			type.name="|E8|/V"			type.wave_name = "|E8|"			type.read = 1			break		case 271:			type.type=4			type.name="Phase(Z1)/deg"			type.wave_name = "Phase(Z1)"			type.read = 1			break		case 272:			type.type=4			type.name="Phase(Z2)/deg"			type.wave_name = "Phase(Z2)"			type.read = 1			break		case 273:			type.type=4			type.name="Phase(Z3)/deg"			type.wave_name = "Phase(Z3)"			type.read = 1			break		case 274:			type.type=4			type.name="Phase(Z4)/deg"			type.wave_name = "Phase(Z4)"			type.read = 1			break		case 275:			type.type=4			type.name="Phase(Z5)/deg"			type.wave_name = "Phase(Z5)"			type.read = 1			break		case 276:			type.type=4			type.name="Phase(Z6)/deg"			type.wave_name = "Phase(Z6)"			type.read = 1			break		case 277:			type.type=4			type.name="Phase(Z7)/deg"			type.wave_name = "Phase(Z7)"			type.read = 1			break		case 278:			type.type=4			type.name="Phase(Z8)/deg"			type.wave_name = "Phase(Z8)"			type.read = 1			break		case 301:			type.type=4			type.name="|Z1|/Ohm"			type.wave_name = "|Z1|"			type.read = 1			break		case 302:			type.type=4			type.name="|Z2|/Ohm"			type.wave_name = "|Z2|"			type.read = 1			break		case 303:			type.type=4			type.name="|Z3|/Ohm"			type.wave_name = "|Z3|"			type.read = 1			break		case 304:			type.type=4			type.name="|Z4|/Ohm"			type.wave_name = "|Z4|"			type.read = 1			break		case 305:			type.type=4			type.name="|Z5|/Ohm"			type.wave_name = "|Z5|"			type.read = 1			break		case 306:			type.type=4			type.name="|Z6|/Ohm"			type.wave_name = "|Z6|"			type.read = 1			break		case 307:			type.type=4			type.name="|Z7|/Ohm"			type.wave_name = "|Z7|"			type.read = 1			break		case 308:			type.type=4			type.name="|Z8|/Ohm"			type.wave_name = "|Z8|"			type.read = 1			break		case 331:			type.type=4			type.name="Re(Z1)/Ohm"			type.wave_name = "Re(Z1)"			type.read = 1			break		case 332:			type.type=4			type.name="Re(Z2)/Ohm"			type.wave_name = "Re(Z2)"			type.read = 1			break		case 333:			type.type=4			type.name="Re(Z3)/Ohm"			type.wave_name = "Re(Z3)"			type.read = 1			break		case 334:			type.type=4			type.name="Re(Z4)/Ohm"			type.wave_name = "Re(Z4)"			type.read = 1			break		case 335:			type.type=4			type.name="Re(Z5)/Ohm"			type.wave_name = "Re(Z5)"			type.read = 1			break		case 336:			type.type=4			type.name="Re(Z6)/Ohm"			type.wave_name = "Re(Z6)"			type.read = 1			break		case 337:			type.type=4			type.name="Re(Z7)/Ohm"			type.wave_name = "Re(Z7)"			type.read = 1			break		case 338:			type.type=4			type.name="Re(Z8)/Ohm"			type.wave_name = "Re(Z8)"			type.read = 1			break		case 361:			type.type=4			type.name="-Im(Z1)/Ohm"			type.wave_name = "-Im(Z1)"			type.read = 1			break		case 362:			type.type=4			type.name="-Im(Z2)/Ohm"			type.wave_name = "-Im(Z2)"			type.read = 1			break		case 363:			type.type=4			type.name="-Im(Z3)/Ohm"			type.wave_name = "-Im(Z3)"			type.read = 1			break		case 364:			type.type=4			type.name="-Im(Z4)/Ohm"			type.wave_name = "-Im(Z4)"			type.read = 1			break		case 365:			type.type=4			type.name="-Im(Z5)/Ohm"			type.wave_name = "-Im(Z5)"			type.read = 1			break		case 366:			type.type=4			type.name="-Im(Z6)/Ohm"			type.wave_name = "-Im(Z6)"			type.read = 1			break		case 367:			type.type=4			type.name="-Im(Z7)/Ohm"			type.wave_name = "-Im(Z7)"			type.read = 1			break		case 368:			type.type=4			type.name="-Im(Z8)/Ohm"			type.wave_name = "-Im(Z8)"			type.read = 1			break		case 391:			type.type=4			type.name="<E1>/V"			type.wave_name = "E1"			type.read = 1			break		case 392:			type.type=4			type.name="<E2>/V"			type.wave_name = "E2"			type.read = 1			break		case 393:			type.type=4			type.name="<E3>/V"			type.wave_name = "E3"			type.read = 1			break		case 394:			type.type=4			type.name="<E4>/V"			type.wave_name = "E4"			type.read = 1			break		case 395:			type.type=4			type.name="<E5>/V"			type.wave_name = "E5"			type.read = 1			break		case 396:			type.type=4			type.name="<E6>/V"			type.wave_name = "E6"			type.read = 1			break		case 397:			type.type=4			type.name="<E7>/V"			type.wave_name = "E7"			type.read = 1			break		case 398:			type.type=4			type.name="<E8>/V"			type.wave_name = "E8"			type.read = 1			break		case 422:			type.type=4			type.name="Phase(Zstack)/deg"			type.wave_name = "Phase"			type.read = 1			break		case 423:			type.type=4			type.name="|Zstack|/Ohm"			type.wave_name = "Zstack"			type.read = 1			break		case 426:			type.type=4			type.name="<Estack>/V"			type.wave_name = "Estack"			type.read = 1			break		case 424:			type.type=4			type.name="Re(Zstack)/Ohm"			type.wave_name = "Re(Zstack)"			type.read = 1			break		case 425:			type.type=4			type.name="-Im(Zstack)/Ohm"			type.wave_name = "-Im(Zstack)"			type.read = 1			break		case 434:			type.type=4			type.name="(Q-Qo)/C"			type.wave_name = "Q"			type.read = 1			break		case 435:			type.type=4			type.name="dQ/C"			type.wave_name = "dQ"			type.read = 1			break		case 436:			type.type=4			type.name="Ece dc/V"			type.wave_name = "Ece dc"			type.read = 1			break		default:				Debugprintf2("Unknown ColID: "+num2str(ID),0)				return -1			break	endswitch	return 0endstatic function BIOLOGICmpr_read_datamodule(file, mprhdr)	variable file ; struct mprmoduleheader &mprhdr	fstatus file	variable oldpos = V_filePOS	variable  n_data_points, n_columns	fbinread /B=3/U/f=3 file, n_data_points// ; print n_data_points	fbinread /B=3/U/f=1 file, n_columns// ; print n_columns	variable i = 0, j=0, tmpd=0	string tmps = ""	struct type type; type.readflags = 0; type.readflags2 = 0	struct alltypes types		switch(mprhdr.version)		case 0:			for(i=0;i<n_columns;i+=1)				fbinread /B=3/U/f=1 file, tmpd// ; print tmpd, i				types.ID[i]=tmpd				if(BIOLOGICmpr_check_datatype(tmpd, type)==-1)					return -1				endif				types.type[i].type=type.type				types.type[i].name=type.name				types.type[i].wave_name = type.wave_name				types.type[i].read = type.read				types.type[i].mask = type.mask			endfor			//remaining_headers  = 			mybinread(file, 100-5-n_columns)			break		case 1: //CV_MP-MEA module.mpr			for(i=0;i<n_columns;i+=1)				fbinread /B=3/U/f=2 file, tmpd// ; print tmpd, i				types.ID[i]=tmpd				if(BIOLOGICmpr_check_datatype(tmpd, type)==-1)					return -1				endif				types.type[i].type=type.type				types.type[i].name=type.name				types.type[i].wave_name = type.wave_name				types.type[i].read = type.read				types.type[i].mask = type.mask			endfor			// remaining_headers = 			mybinread(file, 195-5-2*n_columns)			break		case 2:			for(i=0;i<n_columns;i+=1)				fbinread /B=3/U/f=2 file, tmpd// ; print tmpd, i				types.ID[i]=tmpd				if(BIOLOGICmpr_check_datatype(tmpd, type)==-1)					return -1				endif				types.type[i].type=type.type				types.type[i].name=type.name				types.type[i].wave_name = type.wave_name				types.type[i].read = type.read				types.type[i].mask = type.mask			endfor			// remaining_headers = 			mybinread(file, 405-5-2*n_columns)			break		default:			Debugprintf2("Unknown version for data module: "+num2str(mprhdr.version),0)			return -1			break		endswitch		// check if module is empty	if(n_data_points != 0)		tmpS = "tmpwavearray" ; Make /O/D/N=(n_data_points,n_columns) $tmpS ; wave datawave = $tmpS		for(j=0;j<n_data_points;j+=1)			for(i=0;i<n_columns;i+=1)				tmpd = 0				if((types.type[i].type == 1 || types.type[i].type == 2) &&types.type[i].read ==1)					fbinread /B=3/U/f=(types.type[i].type) file, tmpd				elseif(types.type[i].read ==1)					fbinread /B=3/f=(types.type[i].type) file,tmpd				else				endif				datawave[j][i]=tmpd			endfor		endfor			// set the flags		variable flagcol = -1		variable flag2col = -1		for(i=0;i<n_columns;i+=1)			if(types.ID[i] == 1 || types.ID[i] == 2 || types.ID[i] == 3 || types.ID[i] == 21 || types.ID[i] == 31 || types.ID[i] == 65)				if(flagcol ==-1)					flagcol = i					duplicate /free /R=(0,inf)(i) datawave, tmpflags				endif				if(types.ID[i] == 1)					datawave[][i]=tmpflags[p] & types.type[i].mask				else // cast to bool					datawave[][i]= ((tmpflags[p] & types.type[i].mask)>=1)				endif			endif			if(types.ID[i] == 131)				if(flag2col ==-1)					flag2col = i				duplicate /free /R=(0,inf)(i) datawave, tmpflags2				endif				datawave[][i]= ((tmpflags2[p] & types.type[i].mask)>=1) // cast to bool			endif		endfor				// splitting the datamatrix and rename single waves		tmps = mprhdr.header		note datawave, tmps		splitmatrix(datawave, "0")		for(i=0;i<n_columns;i+=1)			note $("0_spk"+num2str(i)), "Type: "+types.type[i].name			rename $("0_spk"+num2str(i)), $(num2str(i)+"_"+ cleanname(types.type[i].wave_name))		endfor	else		Debugprintf2(" .. empty Data Module!",0)	endif		// check for consistency	fstatus file	variable readpos1 = V_filePOS 	fsetpos file, oldpos	mybinread(file, mprhdr.length)	fstatus file	variable readpos2 = V_filePOS	if(readpos1 != readpos2)		Debugprintf2("Something is wrong!",0)		sprintf tmps,"%08.0f != %08.0f \r", readpos1, readpos2		Debugprintf2(tmps,0)		return -1	endif	return 0endstatic function BIOLOGICmpr_read_setmodule(file, mprhdr)	variable file ; struct mprmoduleheader &mprhdr	fstatus file ; variable oldpos = V_filePOS	string tmps = ""	variable  tmpd	fbinread /B=3/U/f=2 file, tmpd// ; print "??: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "??: ",tmpd //  edits??		fbinread /B=3/U/f=3 file, tmpd// ; print "??: ",tmpd 	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd	print "Comments : "+mybinread(file,tmpd)  // max 255	mybinread(file, 255-tmpd) // skip next chars	fbinread /B=3/U/f=4 file, tmpd ; print "Mass of active Material (mg): ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "at x=: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Molecular weight of active material (at x=0): ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Atomic weight of intercaleted ion: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Aquisition started at: xo= ",tmpd	fbinread /B=3/U/f=2 file, tmpd ; print "Number of e- transfered per intercaletd ion: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "??: ",tmpd //??	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd 	print "Electrode material : "+mybinread(file,tmpd) // max 80 	mybinread(file, 80-tmpd) // skip next chars	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd 	print "Initial state : "+mybinread(file,tmpd) // max 80 	mybinread(file, 80-tmpd) // skip next chars	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd	print "Electrolyte : "+mybinread(file,tmpd) // max 80	mybinread(file, 80-tmpd) // skip next chars	fbinread /B=3/U/f=4 file, tmpd ; print "Electrode surface area: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "length of char: ", tmpd	print "Ref. Electrode: "+mybinread(file, tmpd)	mybinread(file, 50-tmpd) //skip rest of chars	fbinread /B=3/U/f=4 file, tmpd ; print "Voltage shift vs. NHE: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Characteristic mass: ",tmpd	fbinread /B=3/U/f=1 file, tmpd ; print "Flag - Unit (Electrode surface area):", tmpd // Unit (Electrode surface area): 0=m^2; 1=dm^2; 2=cm^2; 3=mm^2; 4=µm^2; 5=nm^2	fbinread /B=3/U/f=1 file, tmpd ; print "Flag - Unit (Characteristic mass):",tmpd // Unit (Characteristic mass): 0=Kg; 1=g; 2=mg; 3=µg	fbinread /B=3/U/f=1 file, tmpd ; print "Flag - ???: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Equivalent Weight: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Density: ",tmpd	fsetpos file, oldpos	mybinread(file, mprhdr.length)	return 0endstatic function BIOLOGICmpr_read_logmodule(file, mprhdr)	variable file ; struct mprmoduleheader &mprhdr	fstatus file ; variable oldpos = V_filePOS	string tmps = ""	variable tmpd, tmpd2	fbinread /B=3/U/f=2 file, tmpd//; print "Version??: ", tmpd // version?	fbinread /B=3/U/f=1 file, tmpd//; print "??", tmpd	fbinread /B=3/U/f=2 file, tmpd//; print "??", tmpd2	fbinread /B=3/U/f=3 file, tmpd//; print "??", tmpd	fbinread /B=3/U/f=1 file, tmpd; print "Run on channel : ", tmpd	mybinread(file, 16)	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "User : "+mybinread(file, tmpd)	mybinread(file, 32-tmpd)	mybinread(file, 258)		// it seams there are several empty fields with the first char giving the size of it	do		fbinread /B=3/U/f=1 file, tmpd// ; print "skip: ", tmpd		mybinread(file, tmpd-1)		Fstatus file	while(tmpd!=0 && V_logEOF>V_filePOS)		fbinread /B=3/U/f=1 file, tmpd// ; print "??: ", tmpd //??	fbinread /B=3/U/f=5 file, tmpd; print "Acquisition started on : ", Secs2Date(tmpd*24*60*60-126316800,-2,"/"), " ", secs2Time(tmpd*24*60*60-126316800,3) // base = 1899, 12, 30, not 1/1/1904 //126316800	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd 	print "Saved on : "+mybinread(file, tmpd) // max 255	mybinread(file, 255-tmpd)	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "Host : "+mybinread(file, tmpd)	mybinread(file, 50-tmpd) // skip rest of string	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "Adress : "+mybinread(file, tmpd)	mybinread(file, 50-tmpd) // skip rest of string	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "EC-Lab for windows (software) : v"+mybinread(file, tmpd)	mybinread(file, 6-tmpd) // skip rest of string	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "Internet server (firmware) : v"+mybinread(file, tmpd)	mybinread(file, 6-tmpd) // skip rest of string	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "Command interpretor (firmware) v: "+mybinread(file, tmpd)	mybinread(file, 9-tmpd) // skip rest of string	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string: ", tmpd	print "Device SN : "+mybinread(file, tmpd)	mybinread(file, 231-tmpd) // lets be generous and consider max 230 (or 231?) chars for the SN	fbinread /B=3/U/f=1 file, tmpd// ; print "???: ",tmpd	fbinread /B=3/U/f=2 file, tmpd// ; print "???: ",tmpd	fbinread /B=3/U/f=2 file, tmpd //; print "???: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd	print "Comments : "+mybinread(file,tmpd)  // max 255	mybinread(file, 255-tmpd) // skip next chars	fbinread /B=3/U/f=4 file, tmpd ; print "Mass of active Material (mg): ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "at x=: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Molecular weight of active material (at x=0): ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Atomic weight of intercaletd ion: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Aquisition started at: xo= ",tmpd	fbinread /B=3/U/f=2 file, tmpd ; print "Number of e- transfered per intercaleted ion: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "??: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd 	print "Electrode material : "+mybinread(file,tmpd) // max 80 	mybinread(file, 80-tmpd) // skip next chars	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd 	print "Initial state : "+mybinread(file,tmpd) // max 80 	mybinread(file, 80-tmpd) // skip next chars	fbinread /B=3/U/f=1 file, tmpd// ; print "length of string ", tmpd	print "Electrolyte : "+mybinread(file,tmpd) // max 80	mybinread(file, 80-tmpd) // skip next chars	fbinread /B=3/U/f=4 file, tmpd ; print "Electrode surface area: ",tmpd	fbinread /B=3/U/f=1 file, tmpd// ; print "length of char: ", tmpd	print "Reference Electrode: "+mybinread(file, tmpd)	mybinread(file, 50-tmpd) //skip rest of chars	fbinread /B=3/U/f=4 file, tmpd ; print "Voltage shift vs. NHE: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Characteristic mass: ",tmpd	fbinread /B=3/U/f=1 file, tmpd ; print "Flag - Unit (Electrode surface area):", tmpd // Unit (Electrode surface area): 0=m^2; 1=dm^2; 2=cm^2; 3=mm^2; 4=µm^2; 5=nm^2	fbinread /B=3/U/f=1 file, tmpd ; print "Flag - Unit (Characteristic mass):",tmpd // Unit (Characteristic mass): 0=Kg; 1=g; 2=mg; 3=µg	fbinread /B=3/U/f=1 file, tmpd ; print "Flag - ???: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Equivalent Weight: ",tmpd	fbinread /B=3/U/f=4 file, tmpd ; print "Density ",tmpd	mybinread(file, 256)	fbinread /B=3/U/f=4 file, tmpd// ; print "??: ",tmpd	fbinread /B=3/U/f=4 file, tmpd// ; print "??: ",tmpd	fbinread /B=3/U/f=4 file, tmpd// ; print "??: ",tmpd	fsetpos file, oldpos	mybinread(file, mprhdr.length)	return 0endfunction BIOLOGICmpr_load_data_info(importloader)	struct importloader &importloader	importloader.name = "BIO-LOGIC"	importloader.filestr = "*.mpr"endfunction BIOLOGICmpr_load_data([optfile])	variable optfile	optfile = paramIsDefault(optfile) ? -1 : optfile	struct importloader importloader	BIOLOGICmpr_load_data_info(importloader)	if(loaderstart(importloader, optfile=optfile)!=0)		return -1	endif	string header = importloader.header	variable file = importloader.file		string tmps = mybinread(file, 48)	variable tmpd = 1	Fbinread /B=3/F=3 file, tmpd	// 4x NULL	if(cmpstr(tmps, "BIO-LOGIC MODULAR FILE                         ")!=0 && tmpd !=0)		Debugprintf2("Invalid header!",0)		loaderend(importloader)		return -1		endif	struct mprmoduleheader mprhdr	mprhdr.header = header	do		// read module list		if(BIOLOGICmpr_read_moduleobject(file, mprhdr) == -1)			Debugprintf2("Error reading Module object!",0)			importloader.success = 1			loaderend(importloader)			return -1		endif		//print mprhdr		strswitch(stripstrfirstlastspaces(mprhdr.shortname))			case "VMP data":				Debugprintf2("---- Found data!",0) 				if(BIOLOGICmpr_read_datamodule(file, mprhdr)==-1)					Debugprintf2("Error reading VMP data module!",0)					loaderend(importloader)					return -1 				endif 				break			case "VMP LOG":				Debugprintf2("---- Found Log!",0)				if(BIOLOGICmpr_read_logmodule(file, mprhdr)==-1)					Debugprintf2("Error reading VMP LOG module!",0)					loaderend(importloader)					return -1 				endif				break			case "VMP Set":				Debugprintf2("---- Found Settings!",0)				if(BIOLOGICmpr_read_setmodule(file, mprhdr)	==-1)					Debugprintf2("Error reading VMP Set module!",0)					loaderend(importloader)					return -1 				endif				break			case "VMP ExtDev":				Debugprintf2("---- Found External Device!",0)				// skip data and go to beginning of next block				mybinread(file, mprhdr.length)							break			case "VMP T° Ctl":				Debugprintf2("---- Found temperature control!",0)				// skip data and go to beginning of next block				mybinread(file, mprhdr.length)							break			case "VMP loop":				Debugprintf2("---- Found expt. loop indexes!",0)				// skip data and go to beginning of next block				mybinread(file, mprhdr.length)							break			default:							Debugprintf2("----------------- Unknown Module type: "+mprhdr.shortname,0)				// skip data and go to beginning of next block				mybinread(file, mprhdr.length)							break		endswitch		fstatus file	while(V_logEOF>V_filePOS)	importloader.success = 1	loaderend(importloader)end